# Introduction TCP

## 超时重传机制
*重传的超时时间 则成为 RTO (Retransmission TimeOut)
*连接的往返时间成为 RTT (Round Trip Time)
*网络是一直波动的, RTT 是一直变化的, RTO 的值基于上次 RTT 往返时间动态计算出来的.
*当 RTO < RTT 时, 将会触发大量的重传, 当 RTO > RTT 时候, 如果频繁出现丢包, 重传不及时,
 又会造成网络的反应慢, 最好的结果是 RTO 略大于 RTT.

*TCP 为了保证可靠性，使用了基于字节序号的 Sequence Number 及 Ack 来确认消息的有序到达。

## 什么是SACK，为啥要引进SACK
tcp的确认系统：
    只有低于ACK number的片段都被收到，才进行ack， out-of-order的片段只能等待，同时这个发送窗口也无法右移。
一般来说常见的以下两种情况：
    1. 只重传超时的数据包，这种方法是最常想到的，比较实用与后面的数据包都能够正常接收的状况，只重传超时的数据包，但是如果比较坏的情况下，丢失了很多封包呢？  那就需要一个一个的等待超时了，很浪费时间。

    2. 重传这个片段以及之后的所有包，这种方法在最坏的状况下，看起来效率还是挺高的，但是如果只有一个包丢失，就去重传后面所有接受到的包，流量浪费也是很严重的。   

针对上述问题，RFC2018提供SACK方法，有效地解决这个问题。

### SACK（Selective Acknowledgment） 介绍
sack是tcp的选项，允许tcp单独确认非连续的片段，用于告知发送端真正丢失的包，只重传丢失的片段。
要使用SACK，2个设备必须同时支持SACK才可以，建立连接的时候需要使用SACK Permitted的option。
如果允许，后续的传输过程中TCP segment中的可以携带SACK option，这个option内容包含一系列的非连续的没有确认的数据的seq range。


## Ack Delay
Tcp 的 Timestamp 选项存在一个问题 [25]，它只是回显了发送方的时间戳，但是没有计算接收端接收到 segment 到发送 Ack 该 segment 的时间。这个时间可以简称为 Ack Delay。
导致RTT过大，而QUIC计算RTT刨掉了ack delay。

## tcp可靠性
TCP 为了保证可靠性，窗口左边沿向右滑动时的长度取决于已经确认的字节数。如果中间出现丢包，就算接收到了更大序号的 Segment，窗口也无法超过这个序列号。

## tcp连接迁移
一条连接是由四元组标识的（源 IP，源端口，目的 IP，目的端口）。
就是当其中任何一个元素发生变化时，这条连接依然维持着，能够保持业务逻辑不中断。当然这里面主要关注的是客户端的变化，因为客户端不可控并且网络环境经常发生变化，而服务端的 IP 和端口一般都是固定的。
比如大家使用手机在 WIFI 和 4G 移动网络切换时，客户端的 IP 肯定会发生变化，需要重新建立和服务端的 TCP 连接。

又比如大家使用公共 NAT 出口时，有些连接竞争时需要重新绑定端口，导致客户端的端口发生变化，同样需要重新建立 TCP 连接。

针对 TCP 的连接变化，MPTCP[5] 其实已经有了解决方案，但是由于 MPTCP 需要操作系统及网络协议栈支持，部署阻力非常大，目前并不适用。

