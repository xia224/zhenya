# 介绍分布式锁
引进分布式锁的原因：  
    例如：单机部署-库存超卖，加同步或者lock解决。多机场景下，需要保证多台机器加的锁是同一把，这就需要分布式锁。  
分布式锁的逻辑：  
    系统提供一个全局唯一的“东东”，拥有了它才可以去操作。

## 基于redis的分布式锁或者原子操作
大致思路：  
    Set if not exists  
    同时设置值和过期时间是原子操作；  
    在redis中设置一个值表示加了锁，释放锁的时候就把key删除。  
Redis 3 种部署方式：  
    *单机模式：存在单点问题
    *Master-slave + Sentinel(哨兵)选举模式：如果master节点故障，发生主从切换，可能会锁丢失   
    *Redis集群模式：
建议企业级开源Redisson，提供了分布式锁的支持，不用自己写代码通过redis设置一个值来实现。  
```java
Config config = new Config(); 
config.useClusterServers() 
.addNodeAddress("redis://192.168.31.101:7001") 
.addNodeAddress("redis://192.168.31.101:7002") 
.addNodeAddress("redis://192.168.31.101:7003") 
.addNodeAddress("redis://192.168.31.102:7001") 
.addNodeAddress("redis://192.168.31.102:7002") 
.addNodeAddress("redis://192.168.31.102:7003"); 
 
RedissonClient redisson = Redisson.create(config);  
RLock lock = redisson.getLock("anyLock"); 
lock.lock(); 
lock.unlock();
```
优缺点：  
    *方式简单粗暴，不断尝试获取锁，比较消耗性能；  
    *不是强一致性，模型不够健壮；  

## 基于zookeep的分布式锁
* ZK包含一系列节点（Znode），类似文件系统的目录；  
* 有序节点：创建节点可指定有序，节点的名字会自动添加整数序号；  
* 临时节点：客户端可创建临时节点，在会话结束或者超时后，ZK会自动删除该节点；  
* 事件监听：读取数据时，可对节点设置事件监听；  
* 事件类型： 节点创建、节点删除、节点数据修改、子节点变更；  

实现分布式锁的逻辑：  
    *每个线程创建一个临时有序的节点，譬如目录/lock/下  
    *创建节点成功后，获取/lock/下的所有临时节点，再判断当前线程创建的节点是否是所有节点中序号最小的节点；  
    *如果当前线程创建的节点是序号最小的节点，则认为获锁成功；  
    *如果不是序号最小的节点，则对节点序号的前一个节点添加一个事件监听；  
    *如果锁释放了，会唤醒下一个序号的节点，然后重新判断是否是序号最小的节点，并执行；  

ZK的开源客户端-Curator，也实现了分布式锁  
优缺点：  
    *天生设计定位：分布式协调，强一致性，模型健壮，简单已用；  
    *获取不到锁，加个监听器就好，不用一直轮询，消耗较小；  
